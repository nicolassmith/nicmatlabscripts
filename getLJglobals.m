global LJ_dtUE9 = 9;
global LJ_dtU3 = 3;
global LJ_dtU6 = 6;
global LJ_ctUSB = 1; % UE9 + U3
global LJ_ctETHERNET = 2; % UE9 only
global LJ_ctETHERNET_MB = 3; % Modbus over Ethernet, UE9 only. 
global LJ_ctUSB_RAW = 101; % UE9 + U3
global LJ_ctETHERNET_RAW = 102; % UE9 only
global LJ_ioGET_AIN = 10; % UE9 + U3.  This is single ended version.  
global LJ_ioGET_AIN_DIFF = 15; % U3 only.  Put negative channel in x1.  If 32 is passed as x1, Vref will be added to the result. 
global LJ_ioGET_AIN_ADVANCED = 16; % For testing purposes. 
global LJ_ioPUT_AIN_RANGE = 2000; % UE9
global LJ_ioGET_AIN_RANGE = 2001; % UE9
global LJ_ioPUT_ANALOG_ENABLE_BIT = 2013; % U3 
global LJ_ioGET_ANALOG_ENABLE_BIT = 2014; % U3 
global LJ_ioPUT_ANALOG_ENABLE_PORT = 2015; % U3 
global LJ_ioGET_ANALOG_ENABLE_PORT = 2016; % U3
global LJ_ioPUT_DAC = 20; % UE9 + U3
global LJ_ioPUT_DAC_ENABLE = 2002; % UE9 + U3 (U3 on Channel 1 only)
global LJ_ioGET_DAC_ENABLE = 2003; % UE9 + U3 (U3 on Channel 1 only)
global LJ_ioGET_DIGITAL_BIT = 30; % UE9 + U3  % changes direction of bit to input as well
global LJ_ioGET_DIGITAL_BIT_DIR = 31; % U3
global LJ_ioGET_DIGITAL_BIT_STATE = 32; % does not change direction of bit, allowing readback of output
global LJ_ioGET_DIGITAL_PORT = 35; % UE9 + U3  % changes direction of bits to input as well
global LJ_ioGET_DIGITAL_PORT_DIR = 36; % U3
global LJ_ioGET_DIGITAL_PORT_STATE = 37; % U3 does not change direction of bits, allowing readback of output
global LJ_ioPUT_DIGITAL_BIT = 40; % UE9 + U3
global LJ_ioPUT_DIGITAL_PORT = 45; % UE9 + U3
global LJ_ioPUT_WAIT = 70; % U3
global LJ_ioGET_COUNTER = 50; % UE9 + U3
global LJ_ioPUT_COUNTER_ENABLE = 2008; % UE9 + U3
global LJ_ioGET_COUNTER_ENABLE = 2009; % UE9 + U3
global LJ_ioPUT_COUNTER_RESET = 2012;  % UE9 + U3 
global LJ_ioGET_TIMER = 60; % UE9 + U3
global LJ_ioPUT_TIMER_VALUE = 2006; % UE9 + U3.  Value gets new value
global LJ_ioPUT_TIMER_MODE = 2004; % UE9 + U3.  On both Value gets new mode.  
global LJ_ioGET_TIMER_MODE = 2005; % UE9
global LJ_ioSHT_GET_READING = 500; % UE9 + U3.
global LJ_ioSPI_COMMUNICATION = 503; % UE9 + U3
global LJ_ioI2C_COMMUNICATION = 504; % UE9 + U3
global LJ_ioASYNCH_COMMUNICATION = 505; % UE9 + U3
global LJ_ioTDAC_COMMUNICATION = 506; % UE9 + U3
global LJ_ioPIN_CONFIGURATION_RESET = 2017; % U3
global LJ_ioRAW_OUT = 100; % UE9 + U3
global LJ_ioRAW_IN = 101; % UE9 + U3
global LJ_ioSET_DEFAULTS = 103; % U3
global LJ_ioADD_STREAM_CHANNEL = 200; % UE9 + U3
global LJ_ioADD_STREAM_CHANNEL_DIFF = 206; % U3
global LJ_ioCLEAR_STREAM_CHANNELS = 201;
global LJ_ioSTART_STREAM = 202;
global LJ_ioSTOP_STREAM = 203;
global LJ_ioADD_STREAM_DAC = 207;
global LJ_ioGET_STREAM_DATA = 204;
global LJ_ioBUZZER = 300; % U3 
global LJ_ioSET_EVENT_CALLBACK = 400;
global LJ_ecDISCONNECT = 1;  % called when the device is unplugged from USB.  No Data is passed
global LJ_ecRECONNECT = 2;   % called when the device is reconnected to USB.  No Data is passed
global LJ_ecSTREAMERROR = 4;  % called when a stream error occurs. Data1 is errorcode, Data2 and Data3 are not used.
global LJ_ioPUT_CONFIG = 1000; % UE9 + U3
global LJ_ioGET_CONFIG = 1001; % UE9 + U3
global LJ_chLOCALID = 0; % UE9 + U3
global LJ_chHARDWARE_VERSION = 10; % UE9 + U3 (Read Only)
global LJ_chSERIAL_NUMBER = 12; % UE9 + U3 (Read Only)
global LJ_chFIRMWARE_VERSION = 11; % UE9 + U3 (Read Only)
global LJ_chBOOTLOADER_VERSION = 15; % UE9 + U3 (Read Only)
global LJ_chCOMM_POWER_LEVEL = 1; %UE9
global LJ_chIP_ADDRESS = 2; %UE9
global LJ_chGATEWAY = 3; %UE9
global LJ_chSUBNET = 4; %UE9
global LJ_chPORTA = 5; %UE9
global LJ_chPORTB = 6; %UE9
global LJ_chDHCP = 7; %UE9
global LJ_chPRODUCTID = 8; %UE9
global LJ_chMACADDRESS = 9; %UE9
global LJ_chCOMM_FIRMWARE_VERSION = 11;  
global LJ_chCONTROL_POWER_LEVEL = 13; %UE9 
global LJ_chCONTROL_FIRMWARE_VERSION = 14; %UE9 (Read Only)
global LJ_chCONTROL_BOOTLOADER_VERSION = 15; %UE9 (Read Only)
global LJ_chCONTROL_RESET_SOURCE = 16; %UE9 (Read Only)
global LJ_chUE9_PRO = 19; % UE9 (Read Only)
global LJ_chLED_STATE = 17; % U3   value = LED state
global LJ_chSDA_SCL = 18; % U3   enable / disable SDA/SCL as digital I/O
global LJ_chU3HV = 22;
global LJ_chU6_PRO = 23;
global LJ_chCOMMUNICATION_TIMEOUT = 20;
global LJ_chSTREAM_COMMUNICATION_TIMEOUT = 21;
global LJ_chCAL_CONSTANTS = 400; % UE9 + U3
global LJ_chUSER_MEM = 402; % UE9 + U3
global LJ_chUSB_STRINGS = 404; % U3
global LJ_chNUMBER_TIMERS_ENABLED = 1000; % UE9 + U3
global LJ_chTIMER_CLOCK_BASE = 1001; % UE9 + U3
global LJ_chTIMER_CLOCK_DIVISOR = 1002; % UE9 + U3
global LJ_chTIMER_COUNTER_PIN_OFFSET = 1003; % U3
global LJ_chAIN_RESOLUTION = 2000; % UE9 + U3
global LJ_chAIN_SETTLING_TIME = 2001; % UE9 + U3
global LJ_chAIN_BINARY = 2002; % UE9 + U3
global LJ_chDAC_BINARY = 3000; % UE9 + U3
global LJ_chSHT_TEMP = 5000; % UE9 + U3
global LJ_chSHT_RH = 5001; % UE9 + U3
global LJ_chSHT_DATA_CHANNEL = 5002; % UE9 + U3. Default is FIO0
global LJ_chSHT_CLOCK_CHANNEL = 5003; % UE9 + U3. Default is FIO1
global LJ_chSPI_AUTO_CS = 5100; % UE9 + U3
global LJ_chSPI_DISABLE_DIR_CONFIG = 5101; % UE9 + U3
global LJ_chSPI_MODE = 5102; % UE9 + U3
global LJ_chSPI_CLOCK_FACTOR = 5103; % UE9 + U3
global LJ_chSPI_MOSI_PIN_NUM = 5104; % UE9 + U3
global LJ_chSPI_MISO_PIN_NUM = 5105; % UE9 + U3
global LJ_chSPI_CLK_PIN_NUM = 5106; % UE9 + U3
global LJ_chSPI_CS_PIN_NUM = 5107; % UE9 + U3
global LJ_chI2C_ADDRESS_BYTE = 5108; % UE9 + U3
global LJ_chI2C_SCL_PIN_NUM = 5109; % UE9 + U3
global LJ_chI2C_SDA_PIN_NUM = 5110; % UE9 + U3
global LJ_chI2C_OPTIONS = 5111; % UE9 + U3
global LJ_chI2C_SPEED_ADJUST = 5112; % UE9 + U3
global LJ_chI2C_READ = 5113; % UE9 + U3
global LJ_chI2C_WRITE = 5114; % UE9 + U3
global LJ_chI2C_GET_ACKS = 5115; % UE9 + U3
global LJ_chI2C_WRITE_READ = 5130; % UE9 + U3
global LJ_chASYNCH_RX = 5117; % UE9 + U3
global LJ_chASYNCH_TX = 5118; % UE9 + U3
global LJ_chASYNCH_FLUSH = 5128; % UE9 + U3
global LJ_chASYNCH_ENABLE = 5129; % UE9 + U3
global LJ_chASYNCH_BAUDFACTOR = 5127; % UE9 + U3
global LJ_chTDAC_SCL_PIN_NUM = 5119; % UE9 + U3:  Used with LJ_ioPUT_CONFIG
global LJ_chTDAC_SERIAL_NUMBER = 5120; % UE9 + U3: Read only
global LJ_chTDAC_READ_USER_MEM = 5121; % UE9 + U3
global LJ_chTDAC_WRITE_USER_MEM = 5122; % UE9 + U3
global LJ_chTDAC_READ_CAL_CONSTANTS = 5123; % UE9 + U3
global LJ_chTDAC_WRITE_CAL_CONSTANTS = 5124; % UE9 + U3
global LJ_chTDAC_UPDATE_DACA = 5125; % UE9 + U3
global LJ_chTDAC_UPDATE_DACB = 5126; % UE9 + U3
global LJ_chSTREAM_SCAN_FREQUENCY = 4000;
global LJ_chSTREAM_BUFFER_SIZE = 4001;
global LJ_chSTREAM_CLOCK_OUTPUT = 4002;
global LJ_chSTREAM_EXTERNAL_TRIGGER = 4003;
global LJ_chSTREAM_WAIT_MODE = 4004;
global LJ_chSTREAM_DISABLE_AUTORECOVERY = 4005; % U3
global LJ_chSTREAM_SAMPLES_PER_PACKET = 4108;
global LJ_chSTREAM_READS_PER_SECOND = 4109;
global LJ_chAIN_STREAM_SETTLING_TIME = 4110; % U6
global LJ_chSTREAM_BACKLOG_COMM = 4105;
global LJ_chSTREAM_BACKLOG_CONTROL = 4106;
global LJ_chSTREAM_BACKLOG_UD = 4107;
global LJ_chALL_CHANNELS = -1;
global LJ_INVALID_CONSTANT = -999;
global LJ_ttB = 6001;
global LJ_ttE = 6002;
global LJ_ttJ = 6003;
global LJ_ttK = 6004;
global LJ_ttN = 6005;
global LJ_ttR = 6006;
global LJ_ttS = 6007;
global LJ_ttT = 6008;
global LJ_rgAUTO = 0;
global LJ_rgBIP20V = 1;  % -20V to +20V
global LJ_rgBIP10V = 2;  % -10V to +10V
global LJ_rgBIP5V = 3;   % -5V to +5V
global LJ_rgBIP4V = 4;   % -4V to +4V
global LJ_rgBIP2P5V = 5; % -2.5V to +2.5V
global LJ_rgBIP2V = 6;   % -2V to +2V
global LJ_rgBIP1P25V = 7;% -1.25V to +1.25V
global LJ_rgBIP1V = 8;   % -1V to +1V
global LJ_rgBIPP625V = 9;% -0.625V to +0.625V
global LJ_rgBIPP1V = 10; % -0.1V to +0.1V
global LJ_rgBIPP01V = 11; % -0.01V to +0.01V
global LJ_rgUNI20V = 101;  % 0V to +20V
global LJ_rgUNI10V = 102;  % 0V to +10V
global LJ_rgUNI5V = 103;   % 0V to +5V
global LJ_rgUNI4V = 104;   % 0V to +4V
global LJ_rgUNI2P5V = 105; % 0V to +2.5V
global LJ_rgUNI2V = 106;   % 0V to +2V
global LJ_rgUNI1P25V = 107;% 0V to +1.25V
global LJ_rgUNI1V = 108;   % 0V to +1V
global LJ_rgUNIP625V = 109;% 0V to +0.625V
global LJ_rgUNIP5V = 110; % 0V to +0.500V
global LJ_rgUNIP25V = 112; % 0V to +0.25V
global LJ_rgUNIP3125V = 111; % 0V to +0.3125V
global LJ_rgUNIP025V = 113; % 0V to +0.025V
global LJ_rgUNIP0025V = 114; % 0V to +0.0025V
global LJ_tmPWM16 = 0; % 16 bit PWM
global LJ_tmPWM8 = 1; % 8 bit PWM
global LJ_tmRISINGEDGES32 = 2; % 32-bit rising to rising edge measurement
global LJ_tmFALLINGEDGES32 = 3; % 32-bit falling to falling edge measurement
global LJ_tmDUTYCYCLE = 4; % duty cycle measurement
global LJ_tmFIRMCOUNTER = 5; % firmware based rising edge counter
global LJ_tmFIRMCOUNTERDEBOUNCE = 6; % firmware counter with debounce
global LJ_tmFREQOUT = 7; % frequency output
global LJ_tmQUAD = 8; % Quadrature
global LJ_tmTIMERSTOP = 9; % stops another timer after n pulses
global LJ_tmSYSTIMERLOW = 10; % read lower 32-bits of system timer
global LJ_tmSYSTIMERHIGH = 11; % read upper 32-bits of system timer
global LJ_tmRISINGEDGES16 = 12; % 16-bit rising to rising edge measurement
global LJ_tmFALLINGEDGES16 = 13; % 16-bit falling to falling edge measurement
global LJ_tc750KHZ = 0;   % UE9: 750 khz 
global LJ_tcSYS = 1;      % UE9 & U3: system clock
global LJ_tc2MHZ = 10;     % U3: Hardware Version 1.20 or lower
global LJ_tc6MHZ = 11;     % U3: Hardware Version 1.20 or lower
global LJ_tc24MHZ = 12;     % U3: Hardware Version 1.20 or lower
global LJ_tc500KHZ_DIV = 13;% U3: Hardware Version 1.20 or lower
global LJ_tc2MHZ_DIV = 14;  % U3: Hardware Version 1.20 or lower
global LJ_tc6MHZ_DIV = 15;  % U3: Hardware Version 1.20 or lower
global LJ_tc24MHZ_DIV = 16; % U3: Hardware Version 1.20 or lower
global LJ_tc4MHZ = 20;     % U3: Hardware Version 1.21 or higher
global LJ_tc12MHZ = 21;     % U3: Hardware Version 1.21 or higher
global LJ_tc48MHZ = 22;     % U3: Hardware Version 1.21 or higher
global LJ_tc1MHZ_DIV = 23;% U3: Hardware Version 1.21 or higher
global LJ_tc4MHZ_DIV = 24;  % U3: Hardware Version 1.21 or higher
global LJ_tc12MHZ_DIV = 25;  % U3: Hardware Version 1.21 or higher
global LJ_tc48MHZ_DIV = 26; % U3: Hardware Version 1.21 or higher
global LJ_swNONE = 1;  % no wait, return whatever is available
global LJ_swALL_OR_NONE = 2; % no wait, but if all points requested aren't available, return none.
global LJ_swPUMP = 11;  % wait and pump the message pump.  Prefered when called from primary thread (if you don't know
global LJ_swSLEEP = 12; % wait by sleeping (don't do this in the primary thread of your app, or it will temporarily 
global LJ_ioSWDT_CONFIG = 507; % UE9 & U3 - Use with LJ_chSWDT_ENABLE or LJ_chSWDT_DISABLE
global LJ_chSWDT_ENABLE = 5200; % UE9 & U3 - used with LJ_ioSWDT_CONFIG to enable watchdog.  Value paramter is number of seconds to trigger
global LJ_chSWDT_DISABLE = 5201; % UE9 & U3 - used with LJ_ioSWDT_CONFIG to enable watchdog.
global LJ_chSWDT_RESET_DEVICE= 5202; % U3 - Reset U3 on watchdog reset.  Write only. 
global LJ_chSWDT_RESET_COMM = 5203; % UE9 - Reset Comm on watchdog reset.  Write only. 
global LJ_chSWDT_RESET_CONTROL = 5204; % UE9 - Reset Control on watchdog trigger.  Write only. 
global LJ_chSWDT_UDPATE_DIOA = 5205; % UE9 & U3 - Update DIO0 settings after reset.  Write only. 
global LJ_chSWDT_UPDATE_DIOB = 5206; % UE9 - Update DIO1 settings after reset.  Write only. 
global LJ_chSWDT_DIOA_CHANNEL = 5207; % UE9 & U3 - DIO0 channel to be set after reset.  Write only. 
global LJ_chSWDT_DIOA_STATE = 5208; % UE9 & U3 - DIO0 state to be set after reset.  Write only. 
global LJ_chSWDT_DIOB_CHANNEL = 5209; % UE9 - DIO1 channel to be set after reset.  Write only. 
global LJ_chSWDT_DIOB_STATE = 5210; % UE9 - DIO0 state to be set after reset.  Write only. 
global LJ_chSWDT_UPDATE_DAC0 = 5211; % UE9 - Update DAC0 settings after reset.  Write only. 
global LJ_chSWDT_UPDATE_DAC1 = 5212; % UE9 - Update DAC1 settings after reset.  Write only. 
global LJ_chSWDT_DAC0 = 5213; % UE9 - voltage to set DAC0 at on watchdog reset.  Write only. 
global LJ_chSWDT_DAC1 = 5214; % UE9 - voltage to set DAC1 at on watchdog reset.  Write only. 
global LJ_chSWDT_DAC_ENABLE = 5215; % UE9 - Enable DACs on watchdog reset.  Default is true.  Both DACs are enabled or disabled togeather.  Write only. 
global LJE_NOERROR = 0;
global LJE_INVALID_CHANNEL_NUMBER = 2; % occurs when a channel that doesn't exist is specified (i.e. DAC #2 on a UE9), or data from streaming is requested on a channel that isn't streaming
global LJE_INVALID_RAW_INOUT_PARAMETER = 3;
global LJE_UNABLE_TO_START_STREAM = 4;
global LJE_UNABLE_TO_STOP_STREAM = 5;
global LJE_NOTHING_TO_STREAM = 6;
global LJE_UNABLE_TO_CONFIG_STREAM = 7;
global LJE_BUFFER_OVERRUN = 8; % occurs when stream buffer overruns (this is the driver buffer not the hardware buffer).  Stream is stopped.
global LJE_STREAM_NOT_RUNNING = 9;
global LJE_INVALID_PARAMETER = 10;
global LJE_INVALID_STREAM_FREQUENCY = 11; 
global LJE_INVALID_AIN_RANGE = 12;
global LJE_STREAM_CHECKSUM_ERROR = 13; % occurs when a stream packet fails checksum.  Stream is stopped
global LJE_STREAM_COMMAND_ERROR = 14; % occurs when a stream packet has invalid command values.  Stream is stopped.
global LJE_STREAM_ORDER_ERROR = 15; % occurs when a stream packet is received out of order (typically one is missing).  Stream is stopped.
global LJE_AD_PIN_CONFIGURATION_ERROR = 16; % occurs when an analog or digital request was made on a pin that isn't configured for that type of request
global LJE_REQUEST_NOT_PROCESSED = 17; % When a LJE_AD_PIN_CONFIGURATION_ERROR occurs, all other IO requests after the request that caused the error won't be processed. Those requests will return this error.
global LJE_SCRATCH_ERROR = 19;
global LJE_DATA_BUFFER_OVERFLOW = 20;
global LJE_ADC0_BUFFER_OVERFLOW = 21; 
global LJE_FUNCTION_INVALID = 22;
global LJE_SWDT_TIME_INVALID = 23;
global LJE_FLASH_ERROR = 24;
global LJE_STREAM_IS_ACTIVE = 25;
global LJE_STREAM_TABLE_INVALID = 26;
global LJE_STREAM_CONFIG_INVALID = 27;
global LJE_STREAM_BAD_TRIGGER_SOURCE = 28;
global LJE_STREAM_INVALID_TRIGGER = 30;
global LJE_STREAM_ADC0_BUFFER_OVERFLOW = 31;
global LJE_STREAM_SAMPLE_NUM_INVALID = 33;
global LJE_STREAM_BIPOLAR_GAIN_INVALID = 34;
global LJE_STREAM_SCAN_RATE_INVALID = 35;
global LJE_TIMER_INVALID_MODE = 36;
global LJE_TIMER_QUADRATURE_AB_ERROR = 37;
global LJE_TIMER_QUAD_PULSE_SEQUENCE = 38;
global LJE_TIMER_BAD_CLOCK_SOURCE = 39;
global LJE_TIMER_STREAM_ACTIVE = 40;
global LJE_TIMER_PWMSTOP_MODULE_ERROR = 41;
global LJE_TIMER_SEQUENCE_ERROR = 42;
global LJE_TIMER_SHARING_ERROR = 43;
global LJE_TIMER_LINE_SEQUENCE_ERROR = 44;
global LJE_EXT_OSC_NOT_STABLE = 45;
global LJE_INVALID_POWER_SETTING = 46;
global LJE_PLL_NOT_LOCKED = 47;
global LJE_INVALID_PIN = 48;
global LJE_IOTYPE_SYNCH_ERROR = 49;
global LJE_INVALID_OFFSET = 50;
global LJE_FEEDBACK_IOTYPE_NOT_VALID = 51;
global LJE_CANT_CONFIGURE_PIN_FOR_ANALOG = 67;
global LJE_CANT_CONFIGURE_PIN_FOR_DIGITAL = 68;
global LJE_TC_PIN_OFFSET_MUST_BE_4_TO_8 = 70;
global LJE_INVALID_DIFFERENTIAL_CHANNEL = 71;
global LJE_SHT_CRC = 52;
global LJE_SHT_MEASREADY = 53;
global LJE_SHT_ACK = 54;
global LJE_SHT_SERIAL_RESET = 55;
global LJE_SHT_COMMUNICATION = 56;
global LJE_AIN_WHILE_STREAMING = 57;
global LJE_STREAM_TIMEOUT = 58;
global LJE_STREAM_CONTROL_BUFFER_OVERFLOW = 59;
global LJE_STREAM_SCAN_OVERLAP = 60;
global LJE_FIRMWARE_VERSION_IOTYPE = 61;
global LJE_FIRMWARE_VERSION_CHANNEL = 62;
global LJE_FIRMWARE_VERSION_VALUE = 63;
global LJE_HARDWARE_VERSION_IOTYPE = 64;
global LJE_HARDWARE_VERSION_CHANNEL = 65;
global LJE_HARDWARE_VERSION_VALUE = 66;
global LJE_LJTDAC_ACK_ERROR = 69;
global LJE_MIN_GROUP_ERROR = 1000; % all errors above this number will stop all requests, below this number are request level errors.
global LJE_UNKNOWN_ERROR = 1001; % occurs when an unknown error occurs that is caught, but still unknown.
global LJE_INVALID_DEVICE_TYPE = 1002; % occurs when devicetype is not a valid device type
global LJE_INVALID_HANDLE = 1003; % occurs when invalid handle used
global LJE_DEVICE_NOT_OPEN = 1004;  % occurs when Open() fails and AppendRead called despite.
global LJE_NO_DATA_AVAILABLE = 1005; % this is cause when GetData() called without calling DoRead(), or when GetData() passed channel that wasn't read
global LJE_NO_MORE_DATA_AVAILABLE = 1006;
global LJE_LABJACK_NOT_FOUND = 1007; % occurs when the LabJack is not found at the given id or address
global LJE_COMM_FAILURE = 1008; % occurs when unable to send or receive the correct # of bytes
global LJE_CHECKSUM_ERROR = 1009;
global LJE_DEVICE_ALREADY_OPEN = 1010; % occurs when LabJack is already open via USB in another program or process
global LJE_COMM_TIMEOUT = 1011;
global LJE_USB_DRIVER_NOT_FOUND = 1012;
global LJE_INVALID_CONNECTION_TYPE = 1013;
global LJE_INVALID_MODE = 1014;
global LJE_DISCONNECT = 2000; 
global LJE_RECONNECT = 2001;
global LJE_MIN_USER_ERROR = 3000;
global LJE_MAX_USER_ERROR = 3999;
global LJE_DEVICE_NOT_CALIBRATED = -1; % defaults used instead
global LJE_UNABLE_TO_READ_CALDATA = -2; % defaults used instead
global LJ_ioANALOG_INPUT = 10;  
global LJ_ioANALOG_OUTPUT = 20; % UE9 + U3
global LJ_ioDIGITAL_BIT_IN = 30; % UE9 + U3
global LJ_ioDIGITAL_PORT_IN = 35; % UE9 + U3 
global LJ_ioDIGITAL_BIT_OUT = 40; % UE9 + U3
global LJ_ioDIGITAL_PORT_OUT = 45; % UE9 + U3
global LJ_ioCOUNTER = 50; % UE9 + U3
global LJ_ioTIMER = 60; % UE9 + U3
global LJ_ioPUT_COUNTER_MODE = 2010; % UE9
global LJ_ioGET_COUNTER_MODE = 2011; % UE9
global LJ_ioGET_TIMER_VALUE = 2007; % UE9
global LJ_ioCYCLE_PORT = 102;  % UE9 
global LJ_chTIMER_CLOCK_CONFIG = 1001; % UE9 + U3 
global LJ_ioPUT_CAL_CONSTANTS = 400;
global LJ_ioGET_CAL_CONSTANTS = 401;
global LJ_ioPUT_USER_MEM = 402;
global LJ_ioGET_USER_MEM = 403;
global LJ_ioPUT_USB_STRINGS = 404;
global LJ_ioGET_USB_STRINGS = 405;
global LJ_ioSHT_DATA_CHANNEL = 501; % UE9 + U3
global LJ_ioSHT_CLOCK_CHANNEL = 502; % UE9 + U3
global LJ_chI2C_ADDRESS = 5108; % UE9 + U3
global LJ_chASYNCH_CONFIG = 5116; % UE9 + U3
global LJ_rgUNIP500V = 110; % 0V to +0.500V
global LJ_ioENABLE_POS_PULLDOWN = 2018; % U6
global LJ_ioENABLE_NEG_PULLDOWN = 2019; % U6
